
```@meta
CurrentModule = MonteCarloMeasurements
DocTestSetup = quote using MonteCarloMeasurements end
```

```@setup usage
using MonteCarloMeasurements
```

# Example [`MonteCarloMeasurement`](@ref) Usage

## Generating a correlated `datastream`

Consider a `datastream` generated by the following code snippet:

```jldoctest usage
julia> stream_length = Int(2^14)
16384

julia> datastream = zeros(Float64, stream_length);

julia> for idx in 1:stream_length
           datastream[idx] = cos( π * idx / 8 ) + (idx % 4) * sin( π * idx / 4 )
       end
```

The function above is crazy and meaningless and just something I made up with correlations. Now we are going to analyze it using both a [`TimeSeries`](@ref) and an [`AccumulatedSeries`](@ref).

## Initialization

One can initialize both [`MonteCarloMeasurement`](@ref)s using the following _pre-allocating_ constructors:

```jldoctest usage
julia> t_series = TimeSeries("Time Series", stream_length);

julia> a_series = AccumulatedSeries("Accumulated Series", stream_length);

```

Note, one does not need to specify the `stream_length`, but then there is no pre-allocated memory. The first argument, a `String` representing the [`name`](@ref) of a given [`MonteCarloMeasurement`](@ref) is optional with the default being empty: `""`. However, this [`name`](@ref) can prove helpful as labels in later analysis or for saving the data. We can retrieve it for an arbitrary [`MonteCarloMeasurement`](@ref) using the [`name`](@ref) function as:

```jldoctest usage
julia> name(t_series) == "Time Series"
true

julia> name(a_series) == "Accumulated Series"
true
```

## [`push!`](@ref)ing data into the [`MonteCarloMeasurement`](@ref)s

At this point, we must input the data from the `datastream` into each measurement. We do this using the [`push!`](@ref) functionality:

```jldoctest usage
julia> push!(t_series, datastream);

julia> push!(a_series, datastream);
```

We note that it's also possible to [`push!`](@ref) single values into [`MonteCarloMeasurement`](@ref)s rather than a whole `Vector` of values.

## Analyzing the `datastream`

Finally, we are in a position to analyze the `datastream` collected by either the [`TimeSeries`](@ref) or the [`AccumulatedSeries`](@ref). 

To do so, we can either apply a [`binning_analysis`](@ref) like the following for the [`TimeSeries`](@ref):

```jldoctest usage
julia> binning_analysis(t_series)
Binning Analysis Result:
    Plateau Present:             true
    Fitted Rx Plateau:           1.0
    Autocorrelation time τₓ:     0.0
    Effective Datastream Length: 16384
    Binning Analysis Mean:       -3.6166273968685214e-16
    Binning Analysis Error:      0.012955960977911544
```

Similarly, we can apply it to the [`AccumulatedSeries`](@ref):

```jldoctest usage
julia> binning_analysis(a_series)
Binning Analysis Result:
    Plateau Present:             true
    Fitted Rx Plateau:           1.0
    Autocorrelation time τₓ:     0.0
    Effective Datastream Length: 16384
    Binning Analysis Mean:       -3.6166273968685214e-16
    Binning Analysis Error:      0.012955960977911544
```

Moreover, one can choose to export either [`MonteCarloMeasurement`](@ref) with the [`measurement`](@ref) function extended from the [`Measurements.jl`](https://juliaphysics.github.io/Measurements.jl/stable/) package.

```jldoctest usage
julia> measurement(t_series)
-3.6e-16 ± 0.013

julia> measurement(a_series)
-3.6e-16 ± 0.013
```

Importantly, this then provides an interface between this [`MonteCarloMeasurements.jl`](https://meese-wj.github.io/MonteCarloMeasurements.jl/stable) package and the utilities found in the [`Measurements.jl`](https://juliaphysics.github.io/Measurements.jl/stable/) package since the return type of [`measurement`](@ref) is given by

```jldoctest usage
julia> typeof( measurement(t_series) )
Measurements.Measurement{Float64}
```

!!! note
    The [`measurement`](@ref) function automatically calls [`binning_analysis`](@ref) on any [`MonteCarloMeasurement`](@ref) argument.

```@meta
DocTestSetup = nothing
```
